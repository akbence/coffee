[#common_module_coffee-module-redisstream]
= coffee-module-redisstream

Modul célja az egyre népszerűbb stream támogatása Redis megszemélyesítésében.
A Redis Stream egy új feature, ami a Redis 5+ verziójába került.
Ötvözi a classic Redis publisher/subscriber funkciót a JMS queue igényeivel,
így egy alternatív megoldást ad a JMS leváltására, helyettesítésére.
A koncepció leírása https://redis.io/topics/streams-intro[Redis streams-intro] oldalon olvasható,
amiból ez az implementáció is indult ki, enterprise igények kiegészítésével. 

== RedisConnection

A coffee-module-redisstream modul a <<coffee-module-redis>> modult használja fel a Redis connection kezelésre.
A Redis kapcsolat beállítása egyezik a <<coffee-module-redis>> leírásnak,
ott lévő "kulcs" alapján történik, csak saját annotáció osztályon keresztül,
ami egyéb stream beállításokat is lehetővé tesz.

== Konfiguráció

A konfiguráció a `@RedisStreamConsumer` qualifier-en keresztül történik.
Konfiguráció yaml-ben:

.yaml config file
[source,yaml]
----
coffee:
   redisstream:
       sampleGroup: #<1>
           stream:
               maxlen: 10 #default: 1000000 <2>
               read:
                   timeoutmillis: 60000 #default: 60000 <3>
           consumer:
               threadsCount: 2 #default: 1 <4>
----
<1> A stream csoport egyedi neve. Minden mező opcionális.
<2> A stream maximális mérete.
Minden új üzenet beszúrásánál kidobja a régebbi üzeneteket a stream-ből,
akkor is ha fel vagy nem volt az dolgozva.
<3> Stream consumer timeoutja - meddig várjon 1 iterációban az üzenetre.
Ha nem érkezik üzenet a streamben ennyi ms ideig,
akkor lezárja a connectiont és egy új iterációban újra nyit egy új connectiont.
<4> Az adott csoport (sampleGroup) consumer mennyi független szálban induljon el.

A fenti konfig-hoz tartozó SampleConsumer használata:

.SampleConsumer.class
[source,java]
----
package hu.icellmobilsoft.redis.consume;

import javax.enterprise.context.Dependent;
import javax.inject.Inject;
import javax.inject.Provider;

import hu.icellmobilsoft.coffee.dto.exception.BaseException;
import hu.icellmobilsoft.coffee.module.redisstream.annotation.RedisStreamConsumer;
import hu.icellmobilsoft.coffee.module.redisstream.consumer.AbstractStreamConsumer;
import hu.icellmobilsoft.coffee.se.logging.Logger;
import hu.icellmobilsoft.sample.requestScope.Counter;
import redis.clients.jedis.StreamEntry;

@Dependent
@RedisStreamConsumer(configKey = "redisConfigKey", group = "sampleGroup")
public class SampleConsumer extends AbstractStreamConsumer {

    @Inject
    private Logger log;

    @Inject
    private Provider<Counter> counterProvider; // <1>

    @Override
    public void process(StreamEntry streamEntry) throws BaseException {
        log.info("Processing streamEntry [{0}]", streamEntry);
        counterProvider.get().print();
    }
}
----
<1> A Counter osztály RequestScope-ban működik, ezért Provider-be kell csomagolni, lásd lejjebb

CAUTION: A `hu.icellmobilsoft.coffee.module.redisstream.annotation.RedisStreamConsumer` annotációval
ellátott osztály kizárólag csak `Dependent` vagy `Application` scope injecteket tartalmazhat,
`RequestScope` osztályokat csak mint `Provider<Counter>` minta lehet,
vagy a `process(StreamEntry streamEntry)` metódusban az inline `CDI.current.select()` megoldással.
Ennek az oka hogy indulásnál `Dependent` scope-al van létrehozva annyi példány amennyi
a beálításban szerepel és ezeket külön szálban vannak használva.

== Hogyan is működik?

Az alkalmazás felfutásánál a CDI `@Observes @Initialized(ApplicationScoped.class)` eventre kikeresi
az összes olyan osztályt, mely:

* `hu.icellmobilsoft.coffee.module.redisstream.consumer.IRedisStreamConsumer`
interfészt implementálja
* `hu.icellmobilsoft.coffee.module.redisstream.annotation.RedisStreamConsumer`
annotációval van ellátva

A talált osztályok annotációjából ismert a redis kapcsolat kulcsa és a stream csoport neve,
amiből kiegészíti a stream kulcs nevét és a beállításokat.
Az osztályokon végig iterál és mindegyik konfigurációja szerint létrehoz annyi példányt,
amit önálló szálakban futtat.

Egy-egy szálban végtelen ciklusban az algoritmus kérdezi a Redis-ből az üzeneteket.
Első körben ellenőrzi hogy van-e megadott csoport és stream, ha nem létrehozza.
További körökben már ezt nem ellenőrzi.
Ha érkezik üzenet, annak az üzleti végrehajtására létrehoz egy automatán kezelt RequestScope-t:

. hogy a szokásos RequestScope logikánk használható legyen az üzenet feldolgozásánál
. minden üzenet tulajdonképpen egy valós requestnek felel meg annyi különbséggel hogy nem REST-en jön
. ez a logika a JMS scope kezelését is követi

A sikeres üzenet feldolgozás után lezárja a RequestScope-t és kiadja az ACK parancsot.

== Nem ACK-olt üzenetek

A jelen implementáció nem foglalkozik a lekért, de nem ACK-olt üzenetekkel.
Ezeket helyileg esetenként kell kezelni hogy mi történjen velük.
Az `hu.icellmobilsoft.coffee.module.redisstream.service.RedisStreamService` osztály
tartalmaz lekérdező és lekezelő metódusokat erre a célra,
amit fel lehet használni a beragadt üzleti folyamatban.
